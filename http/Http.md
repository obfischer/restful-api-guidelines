# HTTP

## {{ book.must }} Use HTTP Methods Correctly

Be compliant with the standardized HTTP method semantics summarized as follows:

### GET

- reads a resource or set of resource instances, respectively
- individual resources will usually generate a 404 if the resource does not exist;
  collection resources may return either 200 or 404 if the listing is empty
- must NOT have request body payload

### PUT:

- fully uploads an entity, i.e. provides a complete replacement by the resource representation
  passed as payload
- resource instance IDs are maintained by the client (either generated by the client or by the server
  in a previous POST request) and passed as a URL path segment
- PUT operations are usually only accepted by single resources, not collection resources, as
  PUT on a collection would imply replacing the entire collection
- usually robust against non-existence of the entity by implicit creation before update

### PATCH:

- partial upload, i.e. only a specific subset of resource fields are replaced
- partial resource representation passed as payload has either resource content type with optional fields (to be
  updated) or a custom content type that also may include instructions of how to change the resource
- usually accepted only by single resources, because the semantics for PATCH on a collection resource
  are very hard to define
- usually not robust against non existence of the entity

### DELETE:

- deletes a resource instance
- DELETE operations are usually only accepted by single resources, not collection resources, as
  DELETE on a collection would imply deleting the entire collection
- should return either status 404 (Not found) or 410 (Gone) if the resource does not exist

### POST:

- creates a resource instance
- resource instance id(s) are created and maintained by server and returned with the output payload
- POST methods should be accepted by collection resources only
- more generally, POST should be used for scenarios that cannot be covered by the other methods.
  For instance, GET with complex (e.g. SQL like structured) query that needs to be passed as
  request body payload. In such cases, make sure to document the fact that POST is used as a
  workaround

### HEAD

- has exactly the same semantics as GET, but returns headers only, no body

### OPTIONS

- returns the available operations (methods) on a given endpoint (usually either as a comma separated list
  of methods or as a structured list of link templates)
- this operation is rarely implemented, though it could be used to self-describe the full functionality
  of a resource.


## {{book.must}}  HTTP Methods must Fulfill Safeness and Idempotency Properties

An operation can be...

- idempotent, i.e. operation will produce the same results if executed once or multiple times (note: this does not
  necessarily mean returning the same status code)
- safe, i.e. must not have side effects such as state changes

Method implementations must fulfill the following basic properties:

| HTTP method  |  safe  |  idempotent |
| --           |  --    |  --         |
| OPTIONS      |  Yes   |  Yes        |
| HEAD         |  Yes   |  Yes        |
| GET          |  Yes   |  Yes        |
| PUT          |  No    |  Yes        |
| POST         |  No    |  No         |
| DELETE       |  No    |  Yes        |
| PATCH        |  No    |  No         |

Please see also [Best Practices \[internal link\]](https://goo.gl/vhwh8a) for further hints on how to support the
different HTTP methods on resources.

## {{ book.must }} Use Meaningful HTTP Status Codes

### Success Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 200  | OK - this is the standard success response | All |
| 201  | Created - Returned on successful entity creation. You are free to return either an empty response or the created resource in conjunction with the Content-Location header. (More details found in the [Common Headers section](../headers/CommonHeaders.md).) *Always* set the Location header. | POST, PUT |
| 202  | Accepted - The request was successful and will be processed asynchronously. | POST, PUT, DELETE, PATCH |
| 204  | No content - There is no response body | PUT, DELETE |

### Redirection Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 301 | Moved Permamently - This and all future requests should be directed to the given URI. | All |
| 303 | See Other - The response to the request can be found under another URI using a GET method.  | PATCH, POST, PUT, DELETE |
| 304 | Not Modified - resource has not been modified since the date or version passed via request headers If-Modified-Since or If-None-Match. | GET |

### Client Side Error Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 400 | Bad request - generic / unknown error | All |
| 401 | Unauthorized - the users must log in (this often means “Unauthenticated”) | All |
| 403 | Forbidden - the user is not authorized to use this resource | All |
| 404 | Not found - the resource is not found | All |
| 405 | Method Not Allowed - the method is not supported, see OPTIONS | All |
| 406 | Not Acceptable - resource can only generate content not acceptable according to the Accept headers sent in the request | All |
| 408 | Request timeout - the server times out waiting for the resource | All |
| 409 | Conflict - returned if, e.g. when two clients try to create the same resource or if there are concurrent, conflicting updates | PUT, DELETE, PATCH |
| 412 | Precondition Failed - returned for conditional requests, e.g. If-Match if the condition failed. Used for optimistic locking. | PUT, DELETE, PATCH |
| 415 | Unsupported Media Type - e.g. clients sends request body without content type | PUT, DELETE, PATCH
| 422 | Unprocessable Entity - semantic error (as opposed to a syntax error which would usually trigger a 400) | POST, PUT, DELETE, PATCH |
| 423 | Locked - Pessimistic locking, e.g. processing states | PUT, DELETE, PATCH |
| 428 | Precondition Required - server requires the request to be conditional (e.g. to make sure that the “lost update problem” is avoided). | All |
| 429 | Too many requests - the client does not consider rate limiting and sent too many requests. See ["Use 429 with Headers for Rate Limits"](#must-use-429-with-headers-for-rate-limits). | All |

### Server Side Error Codes:

| Code | Meaning | Methods |
| --   | --      | --                 |
| 500 | Internal Server Error - a generic error indication for an unexpected server execution problem (here, client retry may be senseful) | All |
| 501 | Not Implemented -  server cannot fulfill the request (usually implies future availability, e.g. new feature). | All |
| 503 | Service Unavailable - server is (temporarily) not available (e.g. due to overload) -- client retry may be senseful. | All |

All error codes can be found in [RFC7231](https://tools.ietf.org/html/rfc7231#section-6) and [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) or via https://httpstatuses.com/<error_code>.

## {{ book.must }} Providing Error Documentation

APIs should define the functional, business view and abstract from implementation aspects. Errors become a key element providing context and visibility into how to use an API. The error object should be extended by an application-specific error identifier if and only if the HTTP status code is not specific enough to convey the domain-specific error semantic. For this reason, we use a standardized error return object definition — see [*Use Common Error Return Objects*](../common-data-objects/CommonDataObjects.md#must-use-common-error-return-objects).

The OpenAPI specification shall include definitions for error descriptions that will be returned; they are part of the interface definition and provide important information for service clients to handle exceptional situations and support troubleshooting. You should also think about a troubleshooting board — it is part of the associated online API documentation, provides information and handling guidance on application-specific errors and is referenced via links of the API definition. This can reduce service support tasks and contribute to service client and provider performance.

Service providers should differentiate between technical and functional errors. In most cases it's not useful to document technical errors that are not in control of the service provider unless the status code convey application-specific semantics. The list of status code that can be omitted from API specifications includes but is not limited to:
- `401 Unauthorized`
- `403 Forbidden`
- `404 Not Found` unless it has some additional semantics
- `405 Method Not Allowed`
- `406 Not Acceptable`
- `408 Request Timeout`
- `413 Payload Too Large`
- `414 URI Too Long`
- `415 Unsupported Media Type`
- `500 Internal Server Error`
- `502 Bad Gateway`
- `503 Service Unavailable`
- `504 Gateway Timeout`

Even though they might not be documented - they may very much occur in production, so clients should be prepared for unexpected response codes, and in case of doubt handle them like they would handle the corresponding x00 code. Adding new response codes (specially error responses) should be considered a compatible API evolution.

Functional errors on the other hand, that convey domain-specific semantics, must be documented and are are strongly encouraged to be expressed with [*Problem types*](../common-data-objects/CommonDataObjects.md#must-use-common-error-return-objects).

## {{ book.must }} Use 429 with Headers for Rate Limits

APIs that wish to manage the request rate of clients must use the ['429 Too Many Requests'](http://tools.ietf.org/html/rfc6585) response code if the client exceeded the request rate and therefore the request can't be fulfilled. Such responses must also contain header information providing further details to the client. There are two approaches a service can take for header information:

 - Return a ['Retry-After'](https://tools.ietf.org/html/rfc7231#section-7.1.3) header indicating how long the client ought to wait before making a follow-up request. The Retry-After header can contain a HTTP date value to retry after or the number of seconds to delay. Either is acceptable but APIs should prefer to use a delay in seconds.
 
 - Return a trio of 'X-RateLimit' headers. These headers (described below) allow a server to express a service level in the form of a number of allowing requests within a given window of time and when the window is reset. 

The 'X-RateLimit' headers are:

- `X-RateLimit-Limit`: The maximum number of requests that the client is allowed to make in this window.
- `X-RateLimit-Remaining`: The number of requests allowed in the current window.
- `X-RateLimit-Reset`: The relative time in seconds when the rate limit window will be reset.

The reason to allow both approaches is that APIs can have different needs. Retry-After is often sufficient for general load handling and request throttling scenarios and notably, does not strictly require the concept of a calling entity such as a tenant or named account. In turn this allows resource owners to minimise the amount of state they have to carry with respect to client requests. The 'X-RateLimit' headers are suitable for scenarios where clients are associated with pre-existing account or tenancy structures. 'X-RateLimit' headers are generally returned on every request and not just on a 429, which implies the service implementing the API is carrying sufficient state to track the number of requests made within a given window for each named entity.
